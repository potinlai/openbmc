#!/bin/bash

# shellcheck source=meta-facebook/recipes-fb/obmc_functions/files/fb-common-functions
source /usr/libexec/fb-common-functions

GPIO_HIGH=1
GPIO_LOW=0

VR_HW=0
PARSEC_HW=1

PDB_RUN_PWR_PG_DELAY_SEC="1"
CPU_RESET_DELAY_SEC="0.2"
SHUTDOWN_FORCE_DELAY_SEC="0.1"

#======================================
# output pins
#======================================
out_pdb_12v_en_n="PDB_12V_EN_N_R-O"
out_usb_pwr_en="USB_PWR_EN-O"

out_pre_sys_rst_n="PRE_SYS_RST_L-O"
out_run_pwr_en="RUN_POWER_EN-O"
out_shdn_req_n="SHDN_REQ_L-O"
out_shdn_force_n="SHDN_FORCE_L-O"

#======================================
# input pins
#======================================
in_shdn_ok_n="CPU_SHDN_OK_L-I"
in_cpu_rst_n="CPU_RST_L-I"
in_run_pwr_pg="RUN_POWER_PG-I"

wait_gpios_value()
{
    local expd_val=$1           # Expected value (e.g., 1)
    local max_retries=$2        # Maximum number of retries (e.g., 50)
    local delay_secs=$3         # Delay in seconds between retries (e.g., 1)
    local net_names=("${@:4}")  # The list of GPIO names.

    if [ ${#net_names[@]} -eq 0 ]; then
        echo "Error: Missing GPIO names for checking."
        return 1
    fi

    declare -A last_values
    local gpio_val=0
    local trycnt=1
    local all_match=1
    local rc=0

    until [[ $trycnt -gt $max_retries ]]; do
        all_match=1
        
        # Iterate through all input GPIO names
        for net_name in "${net_names[@]}"; do
            gpio_val=$(get_gpio "$net_name")
            rc=$?

            if [[ $rc -ne 0 ]]; then
                echo "Error: Unable to read GPIO $net_name (get_gpio returned $rc)."
                return 1
            fi

            if [[ $gpio_val -ne $expd_val ]]; then
                all_match=0
            fi

            #echo "${net_name}: ${gpio_val}"
            last_values["$net_name"]="$gpio_val"
        done

        if [[ $all_match -eq 1 ]]; then
            return 0
        fi

        sleep "$delay_secs"
        ((trycnt++))
    done

    echo "Failure: wait_gpios_value() timeout, retry: $max_retries, delay: $delay_secs"
    echo "--- Last GPIO Readings (Expected: $expd_val) ---"
    for net_name in "${net_names[@]}"; do
        printf "  %s: %s\n" "$net_name" "${last_values["$net_name"]}"
    done
    echo "------------------------------------------------"
    return 1
}

phosphor_log() {
    busctl call \
        xyz.openbmc_project.Logging \
        /xyz/openbmc_project/logging \
        xyz.openbmc_project.Logging.Create \
        Create "ssa{ss}" "$1" "$2" 0
}

phosphor_log_err() {
    local msg=$1
    local logErr="xyz.openbmc_project.Logging.Entry.Level.Error"
    phosphor_log "$msg" "$logErr"
}

phosphor_log_info() {
    local msg=$1
    local logInfo="xyz.openbmc_project.Logging.Entry.Level.Informational"
    phosphor_log "$msg" "$logInfo"
}

chassis_power_cycle()
{
    #set_gpio "RST_STBY_R_L-O" 0
    #set_gpio "PDB_TRAY_RST-O" 1

    host_force_power_off
    set_gpio "BMC_SELF_PWR_CYCLE-O" "$GPIO_HIGH"
}

chassis_power_on()
{
    # MB stabdby power should enabled by before BMC ready
    # So only do checking here.
    if [[ "$(chassis_power_status)" != "on" ]]; then
        return 1
    fi
    return 0
}

chassis_power_status()
{
    if [[ "$(get_gpio "STBY_POWER_PG-I")" -eq 0 ]];then
        echo "off"
    elif [[ "$(get_gpio "B0_M0_STBY_POWER_PG-I")" -eq 0 ]];then
        echo "off"
    elif [[ "$(get_gpio "B1_M0_STBY_POWER_PG-I")" -eq 0 ]];then
        echo "off"
    else
        echo "on"
    fi
}

detect_hw_type()
{
    local hw_type

    if [ -d "/sys/bus/i2c/drivers/pca953x/9-0020" ]; then
        hw_type="$VR_HW"
    elif [ -d "/sys/bus/i2c/drivers/pca953x/9-0075" ]; then
        hw_type="$PARSEC_HW"
    else
        # Unknow type, return VR_HW by default
        hw_type="$VR_HW"
    fi

    echo "$hw_type"
}

pdb_run_pwr_set_n_check()
{
    local hw_type
    local gpio_run_pwr_pg
    local gpio_run_pwr_en
    local gpio_val

    hw_type="$(detect_hw_type)"

    # Get PDB run power good value
    if [[ $hw_type -eq $VR_HW ]]; then
        gpio_run_pwr_pg="MAIN_PWR_OK-I"
        gpio_run_pwr_en="MAIN_PWR_EN-O"
    elif [[ $hw_type -eq $PARSEC_HW ]]; then
        gpio_run_pwr_pg="PDB_12V_PG_R-I"
        gpio_run_pwr_en="PDB_12V_EN_N_R-O"
    else
        return 1
    fi

    # Set PDB run power enable
    if [[ $hw_type -eq $VR_HW ]]; then
        set_gpio "$gpio_run_pwr_en" "$GPIO_HIGH"
    elif [[ $hw_type -eq $PARSEC_HW ]]; then
        set_gpio "$gpio_run_pwr_en" "$GPIO_LOW"
    fi

    sleep "$PDB_RUN_PWR_PG_DELAY_SEC"

    # Check PDB run power good
    if [[ "$(get_gpio "$gpio_run_pwr_pg")" -eq "$GPIO_LOW" ]];then
        echo "ERROR: $gpio_run_pwr_pg failed to assert"

        # Clean up run power enable
        if [[ $hw_type -eq $VR_HW ]]; then
            set_gpio "$gpio_run_pwr_en" "$GPIO_LOW"
        elif [[ $hw_type -eq $PARSEC_HW ]]; then
            set_gpio "$gpio_run_pwr_en" "$GPIO_HIGH"
        fi
        return 1
    fi

    return 0
}

pdb_run_pwr_release_n_check()
{
    local hw_type
    local gpio_run_pwr_pg
    local gpio_run_pwr_en
    local gpio_val

    hw_type="$(detect_hw_type)"

    # Get PDB run power good value
    if [[ $hw_type -eq $VR_HW ]]; then
        gpio_run_pwr_pg="MAIN_PWR_OK-I"
        gpio_run_pwr_en="MAIN_PWR_EN-O"
    elif [[ $hw_type -eq $PARSEC_HW ]]; then
        gpio_run_pwr_pg="PDB_12V_PG_R-I"
        gpio_run_pwr_en="PDB_12V_EN_N_R-O"
    else
        return 1
    fi

    # Set PDB run power disable
    if [[ $hw_type -eq $VR_HW ]]; then
        set_gpio "$gpio_run_pwr_en" "$GPIO_LOW"
    elif [[ $hw_type -eq $PARSEC_HW ]]; then
        set_gpio "$gpio_run_pwr_en" "$GPIO_HIGH"
    fi

    sleep "$PDB_RUN_PWR_PG_DELAY_SEC"

    # Check PDB run power good
    if [[ "$(get_gpio "$gpio_run_pwr_pg")" -eq "$GPIO_HIGH" ]];then
        echo "ERROR: $gpio_run_pwr_pg failed to deassert"
        return 1
    fi

    return 0
}


cpu_reset_set_n_check()
{
    # Set CPUs reset and check
    set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_LOW"
    set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_LOW"

    sleep "$CPU_RESET_DELAY_SEC"

    if [[ "$(get_gpio "$in_cpu_rst_n")" -eq 1 ]]; then
        echo "ERROR: CPUs failed to enter reset"
        return 1
    fi

    return 0
}

cpu_reset_release_n_check()
{
    # Release CPUs reset and check
    set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
    set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"

    sleep "$CPU_RESET_DELAY_SEC"

    if [[ "$(get_gpio "$in_cpu_rst_n")" -eq 0 ]]; then
        echo "ERROR: CPUs failed to exist reset"
        return 1
    fi

    return 0
}

run_pwr_set_n_check()
{
    # Set RUN_POWER_EN, wait RUN_POWER_PG assert, 10s timeout
    set_gpio "B0_M0_${out_run_pwr_en}" "$GPIO_HIGH"
    set_gpio "B1_M0_${out_run_pwr_en}" "$GPIO_HIGH"

    local retry_cnt=11
    local delay_secs=1
    if ! wait_gpios_value "$GPIO_HIGH" "$retry_cnt" "$delay_secs" "B0_M0_${in_run_pwr_pg}" "B1_M0_${in_run_pwr_pg}"; then
        echo "ERROR: HPM RUN_POWER_PG failed to assert"
        return 1
    fi

    return 0
}

run_pwr_release_n_check()
{
    # Release RUN_POWER_EN, wait RUN_POWER_PG deassert, 10s timeout
    set_gpio "B0_M0_${out_run_pwr_en}" "$GPIO_LOW"
    set_gpio "B1_M0_${out_run_pwr_en}" "$GPIO_LOW"

    local retry_cnt=11
    local delay_secs=1
    if ! wait_gpios_value "$GPIO_LOW" "$retry_cnt" "$delay_secs" "B0_M0_${in_run_pwr_pg}" "B1_M0_${in_run_pwr_pg}"; then
        echo "ERROR: HPM RUN_POWER_PG failed to deassert"
        return 1
    fi

    return 0
}

shutdown_force_n_check()
{
    local b0_val
    local b1_val

    # Set Shutdown Force, wait Shutdown OK assert, 100ms timeout
    set_gpio "B0_M0_${out_shdn_force_n}" "$GPIO_LOW"
    sleep "$SHUTDOWN_FORCE_DELAY_SEC"

    b0_val=$(get_gpio B0_M0_${in_shdn_ok_n})
    b1_val=$(get_gpio B1_M0_${in_shdn_ok_n})

    [[ $b0_val -ne 0 ]] && echo "ERROR: B0_M0_${in_shdn_ok_n} failed to assert"
    [[ $b1_val -ne 0 ]] && echo "ERROR: B1_M0_${in_shdn_ok_n} failed to assert"

    if [[ $b0_val -ne 0 || $b1_val -ne 0 ]]; then
        return 1
    fi

    return 0
}

shutdown_request_n_check()
{
    # Set Shutdown Request, wait Shutdown OK assert, 20s timeout
    set_gpio "B0_M0_${out_shdn_req_n}" "$GPIO_LOW"
    set_gpio "B1_M0_${out_shdn_req_n}" "$GPIO_HIGH" # Keep HIGH for HPM 1

    local retry_cnt=21
    local delay_secs=1
    if ! wait_gpios_value "$GPIO_HIGH" "$retry_cnt" "$delay_secs" "B0_M0_${in_shdn_ok_n}" "B1_M0_${in_shdn_ok_n}"; then
        echo "ERROR: HPM CPU_SHDN_OK_L failed to assert"
        return 1
    fi

    return 0
}

host_power_on()
{
    echo "Power On Host"

    local hw_type
    hw_type="$(detect_hw_type)"

    # Check Host Power Status
    if is_host_power_on; then
        echo "Host is already powered on"
        return 0
    fi

    # # Enable PDB 12V
    # set_gpio "$out_pdb_12v_en_n" "$GPIO_LOW"

    # Set PDB run power
    if ! pdb_run_pwr_set_n_check; then
        return 1
    fi

    # Set CPUs reset and check
    if ! cpu_reset_set_n_check; then
        set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        return 1
    fi

    # Enable USB Power
    set_gpio "$out_usb_pwr_en" "$GPIO_HIGH"

    # Enable boot driver power
    if [[ $hw_type -eq $VR_HW ]]; then
        set_gpio "E1S_PWR_EN" "$GPIO_HIGH"
        set_gpio "BMC_SSD0_RST_L" "$GPIO_HIGH"
    fi

    # Set RUN_POWER_EN, wait RUN_POWER_PG assert, 10s timeout
    if ! run_pwr_set_n_check; then
        if [[ $hw_type -eq $VR_HW ]]; then
            set_gpio "MAIN_PWR_EN-O" "$GPIO_LOW"
            sleep "$PDB_RUN_PWR_PG_DELAY_SEC"
        fi
        set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B0_M0_${out_run_pwr_en}" "$GPIO_LOW"
        set_gpio "B1_M0_${out_run_pwr_en}" "$GPIO_LOW"
    fi

    # Release CPUs reset and check
    if ! cpu_reset_release_n_check; then
        set_gpio "B0_M0_${out_run_pwr_en}" "$GPIO_LOW"
        set_gpio "B1_M0_${out_run_pwr_en}" "$GPIO_LOW"
        return 1
    fi

    echo "Power On Host Successfully"
    return 0
}

host_force_power_off()
{
    echo "Force Power Off Host"

    local failed=0
    local hw_type

    hw_type="$(detect_hw_type)"

    # Disable PDB 12V
    set_gpio "$out_pdb_12v_en_n" "$GPIO_HIGH"

    # Check Host Power Status
    if is_host_power_off; then
        echo "Host is already powered off"
        return 0
    fi

    # Set Shutdown Force, wait Shutdown OK assert, 100ms timeout
    if ! shutdown_force_n_check; then
        echo "Continue Force Power Off Sequence..."
    fi

    # Set CPUs reset and check
    if ! cpu_reset_set_n_check; then
        set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B0_M0_${out_shdn_force_n}" "$GPIO_HIGH"
        return 1
    fi

    # Disable USB Power
    set_gpio "$out_usb_pwr_en" "$GPIO_LOW"

    # Disable boot driver power
    if [[ $hw_type -eq $VR_HW ]]; then
        set_gpio "E1S_PWR_EN" "$GPIO_LOW"
        set_gpio "BMC_SSD0_RST_L" "$GPIO_LOW"
    fi

    # Release RUN_POWER_EN, wait RUN_POWER_PG deassert, 10s timeout
    if ! run_pwr_release_n_check; then
        set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B0_M0_${out_shdn_force_n}" "$GPIO_HIGH"
        failed=1
    fi

    if ! pdb_run_pwr_release_n_check; then
        failed=1
    fi

    # Clean up
    set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
    set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
    set_gpio "B0_M0_${out_shdn_force_n}" "$GPIO_HIGH"

    if [[ $failed -eq 1 ]]; then
        echo "Force Power Off Host Failed"
        return 1
    fi

    echo "Force Power Off Host Successfully"
    return 0
}

host_graceful_power_off()
{
    echo "Graceful Power Off Host"

    local failed=0
    local hw_type

    hw_type="$(detect_hw_type)"

    # Check Host Power Status
    if is_host_power_off; then
        echo "Host is already powered off"
        return 0
    fi

    # Set Shutdown Request, wait Shutdown OK assert, 20s timeout
    if ! shutdown_request_n_check; then
        set_gpio "B0_M0_${out_shdn_req_n}" "$GPIO_HIGH"
        return 1
    fi

    # Set CPUs reset and check
    if ! cpu_reset_set_n_check; then
        set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B0_M0_${out_shdn_req_n}" "$GPIO_HIGH"
        return 1
    fi

    # Disable USB Power
    set_gpio "$out_usb_pwr_en" "$GPIO_LOW"

    # Disable boot driver power
    if [[ $hw_type -eq $VR_HW ]]; then
        set_gpio "E1S_PWR_EN" "$GPIO_LOW"
        set_gpio "BMC_SSD0_RST_L" "$GPIO_LOW"
    fi

    # Release RUN_POWER_EN, wait RUN_POWER_PG deassert, 10s timeout
    if ! run_pwr_release_n_check; then
        set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
        set_gpio "B0_M0_${out_shdn_req_n}" "$GPIO_HIGH"
        failed=1
    fi

    if ! pdb_run_pwr_release_n_check; then
        failed=1
    fi

    # Clean up
    set_gpio "B0_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
    set_gpio "B1_M0_${out_pre_sys_rst_n}" "$GPIO_HIGH"
    set_gpio "B0_M0_${out_shdn_req_n}" "$GPIO_HIGH"

    if [[ $failed -eq 1 ]]; then
        echo "Graceful Power Off Host Failed"
        return 1
    fi

    echo "Graceful Power Off Host Successfully"
    return 0
}

host_power_reset()
{

    # Set CPUs reset and check
    if ! cpu_reset_set_n_check; then
        return 1
    fi
    sleep 5

    # Release CPUs reset and check
    if ! cpu_reset_release_n_check; then
        return 1
    fi

    return 0
}

host_power_status()
{
    local run_pwr_pg="RUN_POWER_PG-I"

    hpm0_pg=$(get_gpio "B0_M0_$run_pwr_pg")
    hpm1_pg=$(get_gpio "B1_M0_$run_pwr_pg")

    if [[ "$hpm0_pg" -eq 1 ]] && [[ "$hpm1_pg" -eq 1 ]]; then
        echo "on"
    elif [[ "$hpm0_pg" -eq 0 ]] && [[ "$hpm1_pg" -eq 0 ]]; then
        echo "off"
    else
        echo "inconsistent"
    fi
}

is_host_power_on()
{
    [[ "$(host_power_status)" == "on" ]] && return 0
    return 1
}

is_host_power_off()
{
    [[ "$(host_power_status)" == "off" ]] && return 0
    return 1
}

wait_host_power_change()
{
    local exp_val="$1"
    local max_check_cnt="$2"
    local count=0
    until [[ $count -gt "$max_check_cnt" ]]
    do
        sleep 1
        if [[ "$(host_power_status)" == "$exp_val" ]]; then
            return 0
        fi
        ((count++))
    done

    return 1
}

$*